using ObjParser.Types;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace ObjParser {
    public class Obj {
        /// <summary>Whether the g tag is present in the OBJ file</summary>
        public bool gVerified = false;
        /// <summary>Whether the o tag is present in the OBJ file</summary>
        public bool oVerified = false;

        public string ObjPath = "";
        public List<Vertex> VertexList;
        public List<Face> FaceList;
        public List<TextureVertex> TextureList;
        public List<gf> GroupFaces;
        public List<obj> Objects;

        public Extent Size { get; set; }

        public string UseMtl { get; set; }
        public string Mtl { get; set; }

        /// <summary>
        /// Constructor. Initializes VertexList, FaceList and TextureList.
        /// </summary>
	    public Obj() {
            VertexList = new List<Vertex>();
            FaceList = new List<Face>();
            TextureList = new List<TextureVertex>();
            GroupFaces = new List<gf>();
            Objects = new List<obj>();

            Objects.Add(new obj());
            CurrentObject = Objects[Objects.Count() - 1];
            GroupFaces.Add(new gf());
            //CurrentGroup = GroupFaces[GroupFaces.Count() - 1];
            //CurrentObject.groups.Add(CurrentGroup);
        }

        public class gf {
            public string name;
            public string materialName;
            public List<Face> faces = new List<Face>();

            public override string ToString() {
                return name ?? "";
            }
        }

        public class obj {
            public string name;
            public List<Vertex> vertexList = new List<Vertex>();
            public List<TextureVertex> textureList = new List<TextureVertex>();
            public List<gf> groups = new List<gf>();

            public override string ToString() {
                return name ?? "";
            }
        }
        /// <summary>
        /// Load .obj from a filepath.
        /// </summary>
        /// <param name="file"></param>
        public void LoadObj(string path) {
            ObjPath = path;
            LoadObj(File.ReadAllLines(path));
        }

        /// <summary>
        /// Load .obj from a stream.
        /// </summary>
        /// <param name="file"></param>
	    public void LoadObj(Stream data) {
            using (var reader = new StreamReader(data)) {
                LoadObj(reader.ReadToEnd().Split(Environment.NewLine.ToCharArray()));
            }
        }

        /// <summary>
        /// Load .obj from a list of strings.
        /// </summary>
        /// <param name="data"></param>
	    public void LoadObj(IEnumerable<string> data) {
            foreach (var line in data) {
                processLine(line);
            }

            updateSize();
        }

        public void WriteObjFile(string path, string[] headerStrings) {
            using (var outStream = File.OpenWrite(path))
            using (var writer = new StreamWriter(outStream)) {
                // Write some header data
                WriteHeader(writer, headerStrings);

                if (!string.IsNullOrEmpty(Mtl)) {
                    writer.WriteLine("mtllib " + Mtl);
                }

                VertexList.ForEach(v => writer.WriteLine(v));
                TextureList.ForEach(tv => writer.WriteLine(tv));
                string lastUseMtl = "";
                foreach (Face face in FaceList) {
                    if (face.UseMtl != null && !face.UseMtl.Equals(lastUseMtl)) {
                        writer.WriteLine("usemtl " + face.UseMtl);
                        lastUseMtl = face.UseMtl;
                    }
                    writer.WriteLine(face);
                }
            }
        }

        private void WriteHeader(StreamWriter writer, string[] headerStrings) {
            if (headerStrings == null || headerStrings.Length == 0) {
                writer.WriteLine("# Generated by ObjParser");
                return;
            }

            foreach (var line in headerStrings) {
                writer.WriteLine("# " + line);
            }
        }

        /// <summary>
        /// Sets our global object size with an extent object
        /// </summary>
        private void updateSize() {
            // If there are no vertices then size should be 0.
            if (VertexList.Count == 0) {
                Size = new Extent {
                    XMax = 0,
                    XMin = 0,
                    YMax = 0,
                    YMin = 0,
                    ZMax = 0,
                    ZMin = 0
                };

                // Avoid an exception below if VertexList was empty.
                return;
            }

            Size = new Extent {
                XMax = VertexList.Max(v => v.X),
                XMin = VertexList.Min(v => v.X),
                YMax = VertexList.Max(v => v.Y),
                YMin = VertexList.Min(v => v.Y),
                ZMax = VertexList.Max(v => v.Z),
                ZMin = VertexList.Min(v => v.Z)
            };
        }


        //this is a new custom written method to cater to the way objects and groups are considered in this application.
        //when we are reading v, vt, or f, we must assume we are in an object, thats granted based on the potential inclusion of an O tag
        //however v, vt are part of the groups inside an o, but the group insnt defined until later on
        //this means we have to rewite the way v/vt are collected to store them inside the o
        //
        //consider this:
        // an o contains v/vt and then groups
        //while a g contains f that links to the v/vt in the o
        //so the important point to note is that v/vt are either fully global (no o's in the obj) or they are local to each o
        //unfortunately, this means we may need to remap the faces, ourselves. this will be an incredible pain in the ass
        //to accomidate for this, VertexList is hosted by the o, and when processing the faces, we 



        public obj CurrentObject;
        public gf CurrentGroup;
        /// <summary>
        /// Parses and loads a line from an OBJ file.
        /// Currently only supports V, VT, F and MTLLIB prefixes
        /// </summary>		
        private void processLine(string line) {
            string[] parts = line.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length > 0) {
                switch (parts[0]) {
                    case "usemtl":
                        UseMtl = parts[1];
                        if(CurrentGroup==null) {
                            GroupFaces.Add(new gf());
                            CurrentGroup = GroupFaces[GroupFaces.Count - 1];
                            CurrentGroup.name = parts[1];
                            CurrentObject.groups.Add(CurrentGroup);}
                        CurrentGroup.materialName = UseMtl;
                        break;
                    case "mtllib":
                        Mtl = parts[1];
                        if(Mtl.IndexOf("\\") == -1) {
                            Mtl = Path.GetDirectoryName(ObjPath) + "\\" + Mtl;
                        }
                        break;
                    case "o":
                        //check if we dont already have an active object, aka we arent on the first one
                        if (oVerified) {
                            Objects.Add(new obj());
                        } else {
                            oVerified = true;
                        }
                        //set global to updated object
                        CurrentObject = Objects[Objects.Count() - 1];
                        CurrentObject.name = parts[1];
                        //now any new v, vt, f or g will be added into this object
                        break;
                    case "v":
                        Vertex v = new Vertex();
                        v.LoadFromStringArray(parts);
                        //VertexList.Add(v);
                        //v.Index = VertexList.Count();
                        //because we are now doing it my way, we only add to the current object
                        CurrentObject.vertexList.Add(v);
                        break;
                    case "vt":
                        TextureVertex vt = new TextureVertex();
                        vt.LoadFromStringArray(parts);
                        CurrentObject.textureList.Add(vt);
                        break;
                    case "g":
                        if (gVerified) {
                            GroupFaces.Add(new gf());
                        } else {
                            gVerified = true;
                        }
                        CurrentGroup = GroupFaces[GroupFaces.Count-1];
                        CurrentGroup.name = parts[1];
                        CurrentObject.groups.Add(CurrentGroup);
                        break;
                    case "f":
                        Face f = new Face();
                        f.LoadFromStringArray(parts);
                        f.UseMtl = UseMtl;
                        //FaceList.Add(f);
                        CurrentGroup.faces.Add(f);
                        break;
                }
            }
        }



        /// <summary>
        /// Parses and loads a line from an OBJ file.
        /// Currently only supports V, VT, F and MTLLIB prefixes
        /// </summary>		
        private void processLine2(string line) {
            string[] parts = line.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
            gf CurrentGroup = Objects[Objects.Count - 1].groups[Objects[Objects.Count - 1].groups.Count - 1];
            if (parts.Length > 0) {
                switch (parts[0]) {
                    case "usemtl":
                        UseMtl = parts[1];
                        break;
                    case "mtllib":
                        Mtl = parts[1];
                        break;
                    case "v":
                        Vertex v = new Vertex();
                        v.LoadFromStringArray(parts);
                        VertexList.Add(v);
                        v.Index = VertexList.Count();
                        //CurrentGroup.vertexList.Add(v);
                        //v.Index = CurrentGroup.vertexList.Count();
                        break;
                    case "f":
                        Face f = new Face();
                        f.LoadFromStringArray(parts);
                        f.UseMtl = UseMtl;
                        //FaceList.Add(f);
                        GroupFaces[GroupFaces.Count - 1].faces.Add(f);
                        break;
                    case "vt":
                        TextureVertex vt = new TextureVertex();
                        vt.LoadFromStringArray(parts);
                        TextureList.Add(vt);
                        vt.Index = TextureList.Count();
                        break;
                    case "g":
                        if (gVerified) {
                            GroupFaces.Add(new gf());
                        } else {
                            gVerified = true;
                        }
                        GroupFaces[GroupFaces.Count - 1].name = parts[1];

                        break;
                    case "o":
                        //objects and groups are usually considered indetical, however objects in T2T are used to represent shapes, while groups are used to represent primitives
                        //when an o is encountered, we create a new o into the object list and set our global o pointer to the newly made o
                        //when we do the import, a group faces is a primitive so we can loop through all o's(shapes) and get all GroupFaces(primitives)
                        //there is always a default group 0, and if the user imports an obj with no groups or objects, we just push them all into object 0 group 0
                        if (oVerified) {
                            Objects.Add(new obj());
                        } else {
                            oVerified = true;
                        }
                        Objects[Objects.Count - 1].name = parts[1];
                        Objects[Objects.Count - 1].groups.Add(GroupFaces[GroupFaces.Count - 1]);
                        break;
                }
            }
        }

    }
}
